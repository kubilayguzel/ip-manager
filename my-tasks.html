<script type="module">
        import { authService, taskService, ipRecordsService, personsService, auth, generateUUID } from './firebase-config.js';

        class MyTasksModule {
            constructor() {
                this.currentUser = null;
                this.tasks = [];
                this.allIpRecords = [];
                this.allPersons = [];
                this.allUsers = [];
                this.uploadedCompletionFiles = [];
                this.uploadedEditFiles = [];
                this.currentEditTask = null;
                this.init();
            }

            init() {
                authService.auth.onAuthStateChanged(async user => {
                    if (user) {
                        this.currentUser = authService.getCurrentUser();
                        this.updateUserInfo();
                        await this.loadInitialData();
                        this.setupEventListeners();
                    } else {
                        window.location.href = 'index.html';
                    }
                });
            }

            updateUserInfo() {
                if (this.currentUser) {
                    const userName = this.currentUser.displayName || this.currentUser.email.split('@')[0] || 'Kullanıcı';
                    const userRole = this.currentUser.role === 'admin' ? 'Yönetici' : this.currentUser.role === 'superadmin' ? 'Süper Yönetici' : 'Kullanıcı';
                    document.getElementById('userAvatar').textContent = userName.charAt(0).toUpperCase();
                    document.getElementById('userName').textContent = userName;
                    document.getElementById('userRole').textContent = userRole;
                }
            }
            
            async loadInitialData() {
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('noTasksMessage').style.display = 'none';
                document.getElementById('tasksTableBody').innerHTML = '';
                try {
                    const [tasksResult, ipRecordsResult, personsResult, usersResult] = await Promise.all([
                        taskService.getTasksForUser(this.currentUser.uid),
                        ipRecordsService.getRecords(),
                        personsService.getPersons(),
                        taskService.getAllUsers()
                    ]);

                    if (tasksResult.success) this.tasks = tasksResult.data; else throw new Error(tasksResult.error || 'Görevler yüklenemedi');
                    if (ipRecordsResult.success) this.allIpRecords = ipRecordsResult.data; else throw new Error(ipRecordsResult.error || 'IP Kayıtları yüklenemedi');
                    if (personsResult.success) this.allPersons = personsResult.data; else throw new Error(personsResult.error || 'Kişiler yüklenemedi');
                    if (usersResult.success) this.allUsers = usersResult.data; else throw new Error(usersResult.error || 'Kullanıcılar yüklenemedi');
                    
                    this.renderTasks();

                } catch (error) {
                    console.error('Başlangıç verileri yüklenirken hata:', error);
                    alert('Veriler yüklenirken bir hata oluştu: ' + error.message);
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none';
                }
            }

            setupEventListeners() {
                document.getElementById('logoutBtn').addEventListener('click', () => authService.signOut().then(() => window.location.href = 'index.html'));
                document.getElementById('statusFilter').addEventListener('change', (e) => this.renderTasks(e.target.value));

                // Modals
                document.getElementById('closeViewTaskDetailModal').addEventListener('click', () => this.closeModal('viewTaskDetailModal'));
                document.getElementById('closeEditTaskModal').addEventListener('click', () => this.closeModal('editTaskModal'));
                document.getElementById('cancelEditTaskBtn').addEventListener('click', () => this.closeModal('editTaskModal'));
                document.getElementById('saveTaskChangesBtn').addEventListener('click', () => this.saveTaskChanges());
                document.getElementById('modalTaskDetailFileUploadArea').addEventListener('click', () => document.getElementById('modalTaskDetailFileInput').click());
                document.getElementById('modalTaskDetailFileInput').addEventListener('change', (e) => this.handleEditDocumentUpload(e.target.files));
                document.getElementById('closeCompleteTaskModal').addEventListener('click', () => this.closeModal('completeTaskModal'));
                document.getElementById('cancelCompleteTaskBtn').addEventListener('click', () => this.closeModal('completeTaskModal'));
                document.getElementById('submitCompleteTaskBtn').addEventListener('click', () => this.completeTask('completed_with_doc'));
                document.getElementById('clientApprovalBtn').addEventListener('click', () => this.completeTask('client_approved'));
                document.getElementById('manualCloseBtn').addEventListener('click', () => this.completeTask('manually_closed'));
                document.getElementById('completeTaskDocumentInput').addEventListener('change', (e) => this.handleDocumentUploadForTaskCompletion(e.target.files));
                document.getElementById('completeTaskFileUploadArea').addEventListener('click', () => document.getElementById('completeTaskDocumentInput').click());
                document.getElementById('closeIpRecordModalBtn').addEventListener('click', () => this.closeModal('ipRecordDetailModal'));
            }

            renderTasks(filter = 'all') {
                const tableBody = document.getElementById('tasksTableBody');
                const noTasksMessage = document.getElementById('noTasksMessage');
                tableBody.innerHTML = '';

                // HATA BURADAYDI: Bu satırın var olduğundan emin olun.
                // Bu değişken, görevleri filtrelemek için kullanılır.
                const filteredTasks = this.tasks.filter(task => filter === 'all' || task.status === filter);
                
                if (filteredTasks.length === 0) {
                    noTasksMessage.style.display = 'block';
                    return;
                }
                
                noTasksMessage.style.display = 'none'; 
                const priorityMap = { high: 'Yüksek', medium: 'Orta', low: 'Düşük' };
                const statusMap = { open: 'Açık', in_progress: 'Devam Ediyor', completed: 'Tamamlandı', pending_review: 'Gözden Geçiriliyor' };

                // Hata alınan döngü: 'filteredTasks' artık tanımlı olduğu için sorunsuz çalışacaktır.
                filteredTasks.forEach(task => {
                    const row = document.createElement('tr');
                    const relatedIpRecordTitle = task.relatedIpRecordTitle || '-'; 
                    const relatedIpRecordId = task.relatedIpRecordId || '';

                    row.innerHTML = `
                        <td><span class="priority-${task.priority}">${priorityMap[task.priority] || 'Normal'}</span></td>
                        <td>${task.title}</td>
                        <td><a href="#" class="ip-record-link" data-ip-record-id="${relatedIpRecordId}">${relatedIpRecordTitle}</a></td> 
                        <td>${task.dueDate ? new Date(task.dueDate).toLocaleDateString() : '-'}</td>
                        <td><span class="status-badge status-${task.status}">${statusMap[task.status] || task.status}</span></td>
                        <td>
                            <button class="action-btn view-btn" data-id="${task.id}">Görüntüle</button>
                            <button class="action-btn edit-btn" data-id="${task.id}">Güncelle</button>
                            <button class="action-btn delete-btn" data-id="${task.id}">Sil</button>
                            <button class="action-btn complete-btn" data-id="${task.id}" data-ip-record-id="${task.relatedIpRecordId}" ${task.status === 'completed' ? 'disabled' : ''}>İşi Bitir</button> 
                        </td>
                    `;
                    
                    row.querySelector('.view-btn').addEventListener('click', () => this.viewTaskDetailsModal(task.id));
                    row.querySelector('.edit-btn').addEventListener('click', () => this.editTask(task.id));
                    row.querySelector('.delete-btn').addEventListener('click', () => this.deleteTask(task.id));
                    row.querySelector('.complete-btn').addEventListener('click', () => this.showCompleteTaskModal(task.id, task.relatedIpRecordId));
                    
                    const ipRecordLink = row.querySelector('.ip-record-link');
                    if (ipRecordLink && relatedIpRecordId) {
                        ipRecordLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.showIpRecordDetailModal(relatedIpRecordId);
                        });
                    }
                    tableBody.appendChild(row);
                });
            }
            
            editTask(taskId) { this.showEditTaskModal(taskId); }

            async deleteTask(taskId) {
                if (confirm('Bu görevi silmek istediğinizden emin misiniz? Bu işlem geri alınamaz.')) {
                    try {
                        const result = await taskService.deleteTask(taskId);
                        if (result.success) { alert('Görev başarıyla silindi.'); await this.loadInitialData(); } 
                        else { throw new Error(result.error); }
                    } catch (error) { console.error('Görev silinirken hata:', error); alert('Görev silinirken bir hata oluştu: ' + error.message); }
                }
            }

            async viewTaskDetailsModal(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) { alert('Görev bulunamadı.'); return; }
                this.populateModalTaskDetails(task, this.allIpRecords, this.allPersons);
                document.getElementById('viewTaskDetailModal').classList.add('show');
            }

            showEditTaskModal(taskId) {
                const task = this.tasks.find(t => t.id === taskId);
                if (!task) { alert('Düzenlenecek görev bulunamadı.'); return; }
                this.currentEditTask = task;
                this.uploadedEditFiles = [];
                document.getElementById('editTaskId').value = task.id;
                document.getElementById('modalEditTaskTitle').value = task.title || '';
                document.getElementById('modalEditTaskDescription').value = task.description || '';
                document.getElementById('modalEditTaskDueDate').value = task.dueDate || '';
                const prioritySelect = document.getElementById('modalEditTaskPriority');
                prioritySelect.innerHTML = '';
                const priorities = { low: 'Düşük', medium: 'Orta', high: 'Yüksek' };
                for (const [key, value] of Object.entries(priorities)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = value;
                    if (key === task.priority) option.selected = true;
                    prioritySelect.appendChild(option);
                }
                const assignedToSelect = document.getElementById('modalEditAssignedTo');
                assignedToSelect.innerHTML = '';
                this.allUsers.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.id;
                    option.textContent = user.displayName || user.email;
                    if (user.id === task.assignedTo_uid) option.selected = true;
                    assignedToSelect.appendChild(option);
                });
                this.renderEditFileList(true);
                document.getElementById('editTaskModal').classList.add('show');
            }

            async saveTaskChanges() {
                const taskId = document.getElementById('editTaskId').value;
                const updates = {
                    title: document.getElementById('modalEditTaskTitle').value.trim(),
                    description: document.getElementById('modalEditTaskDescription').value.trim(),
                    priority: document.getElementById('modalEditTaskPriority').value,
                    assignedTo_uid: document.getElementById('modalEditAssignedTo').value,
                    dueDate: document.getElementById('modalEditTaskDueDate').value,
                    files: (this.currentEditTask.files || []).concat(this.uploadedEditFiles)
                };
                updates.assignedTo_email = this.allUsers.find(u => u.id === updates.assignedTo_uid)?.email;
                try {
                    const result = await taskService.updateTask(taskId, updates);
                    if (result.success) {
                        alert('İş başarıyla güncellendi!');
                        this.closeModal('editTaskModal');
                        await this.loadInitialData();
                    } else { throw new Error(result.error); }
                } catch(error) { alert('İş güncellenirken bir hata oluştu: ' + error.message); }
            }

            handleEditDocumentUpload(files) {
                for (const file of files) {
                    const isDuplicate = (this.currentEditTask.files || []).some(f => f.name === file.name) || this.uploadedEditFiles.some(f => f.name === file.name);
                    if(isDuplicate) { alert(`"${file.name}" adlı dosya zaten listede.`); continue; }
                    this.readFileAsDataURL(file).then(dataUrl => {
                        this.uploadedEditFiles.push({
                            id: generateUUID(), name: file.name, size: file.size, type: file.type,
                            content: dataUrl, uploadedAt: new Date().toISOString(),
                            documentDesignation: 'İş Güncelleme Dokümanı'
                        });
                        this.renderEditFileList();
                    });
                }
            }

            renderEditFileList(isInitial = false) {
                const existingList = document.getElementById('modalEditTaskDocumentList');
                const newList = document.getElementById('modalTaskDetailUploadedFileList');
                if (isInitial) {
                    existingList.innerHTML = '';
                    const existingFiles = this.currentEditTask.files || [];
                    if (existingFiles.length === 0) { existingList.innerHTML = '<li id="modalNoTaskDocumentsMessage">Henüz doküman yok.</li>';
                    } else {
                        existingFiles.forEach(file => {
                            const li = document.createElement('li');
                            li.innerHTML = `<a href="${file.content}" download="${file.name}">📄 ${file.name}</a><button class="remove-doc-btn" data-id="${file.id}">×</button>`;
                            li.querySelector('.remove-doc-btn').addEventListener('click', (e) => {
                                if(confirm('Bu dokümanı kalıcı olarak silmek istediğinizden emin misiniz?')) {
                                    this.currentEditTask.files = this.currentEditTask.files.filter(f => f.id !== e.target.dataset.id);
                                    this.renderEditFileList(true);
                                }
                            });
                            existingList.appendChild(li);
                        });
                    }
                }
                newList.innerHTML = '';
                this.uploadedEditFiles.forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item-task-detail';
                    item.innerHTML = `<span>${file.name}</span><button class="remove-file-task-detail" data-id="${file.id}">×</button>`;
                    item.querySelector('.remove-file-task-detail').addEventListener('click', (e) => {
                        this.uploadedEditFiles = this.uploadedEditFiles.filter(f => f.id !== e.target.dataset.id);
                        this.renderEditFileList();
                    });
                    newList.appendChild(item);
                });
            }

            populateModalTaskDetails(task, ipRecords, persons) { /* Unchanged */ }

            closeModal(modalId) {
                document.getElementById(modalId).classList.remove('show');
                if (modalId === 'completeTaskModal') {
                    this.uploadedCompletionFiles = [];
                    document.getElementById('completeTaskFileList').innerHTML = '';
                }
                if (modalId === 'editTaskModal') { this.uploadedEditFiles = []; this.currentEditTask = null; }
            }
            
            showCompleteTaskModal(taskId, relatedIpRecordId) {
                document.getElementById('completeTaskId').value = taskId;
                document.getElementById('completeTaskRelatedIpRecordId').value = relatedIpRecordId;
                this.uploadedCompletionFiles = [];
                document.getElementById('completeTaskFileList').innerHTML = '';
                document.getElementById('completeTaskModal').classList.add('show');
            }

            async completeTask(actionType) {
                const taskId = document.getElementById('completeTaskId').value;
                const relatedIpRecordId = document.getElementById('completeTaskRelatedIpRecordId').value;
                if (!taskId) { alert('İş ID\'si bulunamadı.'); return; }
                const actionMessages = {
                    completed_with_doc: { confirm: 'Bu işi "Tamamlandı" olarak işaretlemek istediğinizden emin misiniz?', success: 'İş başarıyla tamamlandı!' },
                    client_approved: { confirm: 'Bu işi "Müvekkil Onayı" ile tamamlamak istediğinizden emin misiniz?', success: 'İş, müvekkil onayı ile tamamlandı!' },
                    manually_closed: { confirm: 'Bu işi "Manuel Kapat" olarak işaretlemek istediğinizden emin misiniz?', success: 'İş, manuel olarak kapatıldı!' }
                };
                const messages = actionMessages[actionType];
                if (confirm(messages.confirm)) {
                    try {
                        const result = await taskService.updateTask(taskId, { status: 'completed' });
                        if (!result.success) throw new Error(result.error || 'İş durumu güncellenemedi.');
                        if (this.uploadedCompletionFiles.length > 0 && relatedIpRecordId) {
                            const currentIpRecord = this.allIpRecords.find(r => r.id === relatedIpRecordId);
                            const updatedFiles = (currentIpRecord?.files || []).concat(this.uploadedCompletionFiles);
                            const ipRecordUpdateResult = await ipRecordsService.updateRecord(relatedIpRecordId, { files: updatedFiles });
                            if (!ipRecordUpdateResult.success) {
                                alert(`${messages.success} Ancak dokümanlar yüklenirken bir hata oluştu: ${ipRecordUpdateResult.error}`);
                            } else {
                                alert(`${messages.success} Dokümanlar da başarıyla yüklendi!`);
                            }
                        } else {
                            alert(messages.success);
                        }
                        this.closeModal('completeTaskModal');
                        await this.loadInitialData();
                    } catch (error) {
                        alert('İş tamamlanırken bir hata oluştu: ' + error.message);
                    }
                }
            }

            handleDocumentUploadForTaskCompletion(files) { /* Unchanged */ }
            renderDocumentListForTaskCompletion() { /* Unchanged */ }
            readFileAsDataURL(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(file); }); }
            formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${['Bytes', 'KB', 'MB', 'GB'][i]}`; }
            async showIpRecordDetailModal(recordId) { /* Unchanged */ }
            renderIpRecordTransactionHistory(recordId, transactions, recordFiles) { /* Unchanged */ }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const accordions = document.querySelectorAll('.accordion-header');
            accordions.forEach(accordion => { accordion.addEventListener('click', function(event) { this.classList.toggle('active'); const content = this.nextElementSibling; if (content.style.maxHeight) { content.style.maxHeight = null; } else { content.style.maxHeight = content.scrollHeight + "px"; } }); });
            function setActiveMenu() { const currentPage = window.location.pathname.split("/").pop() || 'dashboard.html'; document.querySelectorAll('.sidebar-nav-item.active, .accordion-content a.active').forEach(el => el.classList.remove('active')); const activeLink = document.querySelector(`.sidebar-nav a[href="${currentPage}"]`); if (!activeLink) return; activeLink.classList.add('active'); const parentAccordionContent = activeLink.closest('.accordion-content'); if (parentAccordionContent) { const parentAccordionHeader = parentAccordionContent.previousElementSibling; if (parentAccordionHeader && parentAccordionHeader.classList.contains('accordion-header')) { parentAccordionHeader.classList.add('active'); parentAccordionContent.style.maxHeight = parentAccordionContent.scrollHeight + "px"; } } }
            setActiveMenu();
        });

        let myTasksModuleInstance;
        auth.onAuthStateChanged((user) => {
            if (user || authService.getCurrentUser()) {
                if (!myTasksModuleInstance) {
                    myTasksModuleInstance = new MyTasksModule();
                }
            } else {
                window.location.href = 'index.html';
            }
        });
    </script>
</body>
</html>